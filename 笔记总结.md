-----





Python学习笔记

### 第一章 计算机基础

​	部分忽略...O(∩_∩)O哈哈~(#^.^#)

#### 1.3 解释器或编译器

编程语言的开发者的一个工具，将代码转化为010101交给系统去处理执行

##### 1.3.1 解释和编译型语言

​	解释型语言类似：实时翻译，代表:Python/PHP/Ruby/Perl

​	编译型语言类似：说完之后，整体再进行翻译，代表：C/C++/Java/Go ...

### 第二章 Python入门

#### 2.1 编码

##### 2.1.1编码基础

8位 ==1字节

- ascii    8位 
- unicode  32位 
- utf-8  优化unicode，缩小长度 中文3字节
- gbk  中文2个字节
- gb2312 中文2个字节

##### 2.1.2 python编码相关

对于python默认解释器编码

- python2：ascii

- python3：utf-8

  如果想修改默认编码，则可以使用：

  ```
  #!/usr/bin/env python
  #-*- coding:utf-8 -*-
  ```

  注意：文件操作时，要按照：以什么编码写入，就以什么编码读取

##### 2.1.3运算符

![image-20200110182807603](C:\Users\davidlu\AppData\Roaming\Typora\typora-user-images\image-20200110182807603.png)

```
val=v if v else 666
val=v or 666
```

2.1.4 深浅copy

针对可变类型，将重新创建一份

- 浅拷贝：拷贝第一层
- 深拷贝：所有层

修改时 需要注意是赋值还是对内部进行修改。

```
import copy
v=[11，22，33，44]
v2=copy.copy(v1)
v3=copy.deepcopy(v1)
```



### 第三章 数据类

#### 3.1 整型（int）

##### 3.1.1 整型的长度

py2中有：int/long，长度受到操作系统位限制

py3中有：int（int/long）

##### 3.1.2 整除

py2与py3中整除不一样。

py2中整除只取整数部分，如果要取到小数点部分则需要导入from_future_import division

3.1.3 进制转换

bin

oct

hex

int

```
int('010101',base=2)
```

#### 3.2 布尔（bool）

布尔值就是用于表示真假。True和False

其他类型转换为布尔值：

- str

- int

- list

- tuple

- set（）

- dict

- None

  对于 None/' '/0/[]/set()/{}/() --->false。

#### 3.3 字符串（str）

```
#一般用于内存中进行数据操作
v='luwei' #unicode编码存储在内存
```

​		字符串是写代码中最常见的，python内存中的字符串是按照：unicode 编码存储。对于字符串是不可变。

公共方法:索引、切片、for循环、步长、len、删除（不支持）、修改（不支持）

​		字符串自己有很多方法，如：

​	1.大写（upper）

```
v = 'ALEX'
v1 = v.upper()
print(v1)
v2 = v.isupper() # 判断是否全部是大写
print(v2)
```

​	2.小写（lower）

```
v = 'alex'
v1 = v.lower()
print(v1)
v2 = v.islower() # 判断是否全部是小写
print(v2)

############ 了解即可
v = 'ß'
# 将字符串变小写（更牛逼）
v1 = v.casefold()
print(v1) # ss
v2 = v.lower()
print(v2)
```

​	3.判断是否是数字 推荐使用isdecimal

- ​	isdigit 	   

- ​	isdecimal  只用于判断10进制的数

- ​	isnumeric

  ```
  #v='1'
  #v='一'
  v='①'
  v1=v.isdigit()      #'1'-->True，'一'-->False，'①'-->True
  v2=v.isdecimal()    #'1'-->True，'一'-->False，'①'-->False
  v3=v.isnumeric()    #'1'-->True，'一'-->True，'①'-->True
  print(v1,v2,v3)
  
  注意：  
  	以后推荐使用isdecimal，因为isdecimal() 只用于判断10进制的数。
  	isdigit和isnumeric判断字符串是否为数字范围比较广。
  ```

  4. strip	可以去除空格+换行符（\n）+制表符（\t）+指定字符串

     ​			制表符就是一个tab键=4个空格

  ```
  v='alexok\t'
  print(v.strip())
  
  v='alexok\n'
  print(v.strip())
  
  v='alexok     '
  print(v.strip())
  
  v='lwasdfalw'
  print(v.strip('lw'))
  ```

  5. replace

     ```
     v='lwasdfalw'
     v1=v.replace('lw','12',1)
     print(v1)
     ```

  6. statswith/endswith

     ```
     v='lwasdfalw'
     print(v.startswith('lw'))
     print(v.endswith('lw'))
     ```

  7. encode 

     ```
     v='lwasdfalw'
     data=v.encode('utf-8')
     print(data)
     ```

  8. format

     ```
     v='lw'
     v1='wl'
     print('{0},{1},haha'.format(v,v1))
     ```

  9. jion

     ```
     v='123asd'
     v1='_'.join(v)
     print(v1)
     ```

  10. split 

      ```
      v='1,2,3,ams,d,'
      print(v.split(','))#生成列表
      ```

  11. 字符串格式化

  ```
  # msg='我是%s,年龄%s'%('陆威','19')
  # print(msg)
  
  # msg='我是%(n1)s,年龄%(n2)s'%{'n1':'陆威','n2':'19'}
  # print(msg)
  
  msg='我是{0},年龄{1}'.format('陆威','19')
  print(msg)
  
  msg='我是{name},年龄{age}'.format(name='陆威',age='19')
  print(msg)
  ```
  
  5. 几种不需要记的方法
  
     ```
     1.capitalize 首字母大写
     v='asdwqexzc'
     print(v.capitalize())
     
     2.casefold()
     v1='QasaWd'
     print(v1.casefold())#返回将字符串中所有大写字符转换为小写后生成的字符串。
     
     3.center字符串居中
     v='lw'
     print(v.center(20,'+'))#长度20，字符串居中，不够地方使用'+'填充
     
     4.ljust/rjust
     v='lw'
     print(v.ljust(20,'+'))#长度20，字符串在左边，不够地方使用'+'填充
     print(v.ljust(20,'+'))#长度20，字符串在右边，不够地方使用'+'填充
     
     4.count
     v='lasdsadasdw'
     print(v.count('a'))#计算子序列出现的次数
     
     5.find 
     #从左往右默认找到第一个字符对应的索引位置，后面可以指定第几个字符。存在则范围索引位置，不存在则返回-1。
     v='lasdsadasdw'
     index=v.find('a')
     
     6.index
     #从左往右默认找到第一个字符对应的索引位置，后面可以指定第几个字符。存在则范围索引位置，不存在则报错。
     v='lasdsadasdw'
     index=v.index('a')
     
     7.format/format_map
     v='我是{0}，今年{1}'.format('luwei',18)
     print(v)
     v='我是{k1}，今年{k2}'.format_map({'k1':'luwei','k2':'18'})
     print(v)
     
     8.partition
     v='asd12jkgygfj1fgfgj1jhg'
     print(v.partition('1'))#生成元组，分成前半部分 自己 后半部分
     -->('asd', '1', '2jkgygfj1fgfgj1jhg')
     
     9.swapcase 大小写互换
   v='AJaHasdlkw'
     print(v.swapcase())
     
     10.zfill
     v='AJaw'
     print(v.zfill(10))#填充0
     -->000000AJaw
     
     11.maketrans
     a='1234'
     b='abcd'
     table=str.maketrans(b,a)
     v='asdawqeqrqasdasdaswq'
     r=v.translate(table)
     print(r)
     ```
  
     

####       3.4 bytes 字节类型

```
v='luwei'.encode('utf-8')#将字符串转换成字节（由unicode编码转换为utf-8编码）
v='luwei'.encode('gbk')#将字符串转换成字节（由unicode编码转换为gbk编码） 	
#一般用于数据存储和网络传输
```



####       3.5 列表list[]

​	1.append 追加

```
l=[]
v='asdqwe'
for i in v:
    l.append(i)
print(l)
```

2. insert 插入

```
l=['a', 's', 'd', 'q', 'w', 'e']
l.insert(0,'A')
print(l)
```

3. extend 扩展

```
l1=['1','2',1,2,3]
l2=['a','v','g']
l1.extend(l2)
print(l1)
```

4. reverse 反转

```
l=['a', 's', 'd', 'q', 'w', 'e']
l.reverse()
print(l)
```

5. sort(reverse=False)默认从小到大 or sort(reverse=True) 从大到小

```
l=['a', 's', 'd', 'q', 'w', 'e']
l.sort(reverse=True)
print(l)
```

6. pop/remove/clear

```
l=['a', 's', 'd', 'q', 'w', 'e']
a=l.pop()
print(l,a)#pop可以将删除的值进行赋值

l=['a', 's', 'd', 'q', 'w', 'e']
l.remove('a')
print(l)

l=['a', 's', 'd', 'q', 'w', 'e']
l.clear()
print(l)#不能将删除的值进行赋值

l=['a', 's', 'd', 'q', 'w', 'e']
del l[0]
print(l)#不能将删除的值进行赋值
```

 

####  3.5 元组tuple（）

​	1.无

#### 	  3.6 字典dict { }

#在python 3.7之后字典才是有序的，3.7之前如果想让字典有序可以使用OrdereDict

```
from collections import OrderedDict

info = OrderedDict()
info['k1']=123 #__setitem__
info['a']      #__getitem__
info['k2']=456 
print(info)
```



1. key

```
d={'k1':'v1','k2':'v2','k3':'v3'}
for i in d.keys():
    print(i)
```

2. values

```
d={'k1':'v1','k2':'v2','k3':'v3'}
for i in d.values():
    print(i)
```

3. items

```
d={'k1':'v1','k2':'v2','k3':'v3'}
for a,b in d.items():
    print(a,b)
```

4. get

```
d={'k1':'v1','k2':'v2','k3':'v3'}
print(d.get('k1'))
```

5. update

```
d={'k1':'v1','k2':'v2','k3':'v3'}
d1={'k4':'v1'}
d.update(d1)
print(d)
```

6. pop/clear

```
d={'k1':'v1','k2':'v2','k3':'v3'}
d.pop('k1')
print(d)


d={'k1':'v1','k2':'v2','k3':'v3'}
d.clear()
print(d)
```



#### 3.7 集合set()

1. add

```
s={'a','a','s', 'd', 'q', 'w', 'e'}
s.add('aaaa')
print(s)
```

2. discard/remove/clear/pop

```
s={'a','a','s', 'd', 'q', 'w', 'e'}
s.discard('a')
print(s)

s={'a','a','s', 'd', 'q', 'w', 'e'}
s.remove('a')
print(s)

s={'a','a','s', 'd', 'q', 'w', 'e'}
s.pop()
print(s)

s={'a','a','s', 'd', 'q', 'w', 'e'}
s.clear()
print(s)
```

3. update

```
s={'a','a','s', 'd', 'q', 'w', 'e'}
s1={1,2,3,4,5}
s.update(s1)
print(s)
```

4. intersection

```
s={'a','v','b','q','w'}
s1={'q','v','b','w'}
print(s.intersection(s1))
```

5. union

```
s={'a','v','b','q','w'}
s1={'q','v','b','w','k'}
print(s.union(s1))
```

6. difference

```
s={'a','v','b','q','w'}
s1={'q','v','b','w','k'}
print(s.difference(s1))
```

7. symmetric_difference

```
s={'a','v','b','q','w'}
s1={'q','v','b','w','k'}
print(s.symmetric_difference(s1))
```



####  3.8 公共功能

|          | len  | 索引 | 切片 | 步长 | for循环 | 修改 | 删除 | 是否为可变型 |
| -------- | ---- | ---- | ---- | ---- | ------- | ---- | ---- | ------------ |
| int      |      |      |      |      |         |      |      | 不可变       |
| bool     |      |      |      |      |         |      |      | 不可变       |
| str      | √    | √    | √    | √    | √       |      |      | 不可变       |
| list[]   | √    | √    | √    | √    | √       | √    | √    | 可变         |
| tuple()  | √    | √    | √    | √    | √       |      |      | 不可变       |
| dict（） | √    | √    |      |      | √       | √    | √    | 可变         |
| set（）  | √    |      |      |      | √       |      |      | 可变         |

注意：只有不可变型才能做字典的key（包含None）

#### 	  3.9 嵌套

列表嵌套

```
users=['luwei',0,Ture,[11,22,33,'oldboy']]
users[3]-->[11,22,33,'oldboy']
users[3][3]-->'oldboy'
users[3][3][-1]-->'y'
users[3]='newone' #可以修改，列表是可变类型
users[3][3][-1]='X'#不可以修改，字符串为不可变类型
```



### 第四章 文件操作

#### 4.1 文件基本操作

```
obj=open('路径'，mode='模式'，encoding='编码')
obj.write()
obj.read()
obj.close()
```

#### 4.2 打开模式

```
r/w/a
r+/w+/a+
rb/wb/ab
r+b/w+b/a+b
```

#### 4.3 操作

read(),全部读到内存，是以str形式存储在内存中

readlin()只读一行到内存，是以str形式存储在内存中

readlines()全部按行读取到内存，是以list形式存储在内存中

read(2)

- 2表示两个字符

```
obj=open('a.text',mode='r',encoding='utf-8')
data=obj.read(2)#2个字符
obj.close()
print(data)
```

- 2表示两个字节

```
obj=open('a.text',mode='rb')
data=obj.read(6)#6个字符
obj.close()
print(data.decode('utf-8'))
```

write(字符串)

```
obj=open('a.text',mode='w',encoding='utf-8')
obj.write('个字符')#2个字符
obj.close()
```

write(二进制)

```
obj=open('a.text',mode='w')
obj.write('个字符'.decode('utf-8'))
obj.close()
```

seek(光标字节位置) 无论模式是否带b，都是按**字节**进行处理



tell( )获取光标当前所在的**字节**位置。



flush() 强行将写入进内存的内容刷入硬盘中。

```
obj=open('a.text',mode='a',encoding='utf-8')
while True:
    val=input('----')
    obj.write(val)
    obj.flush()
obj.close()
```

#### 4.4关闭文件

执行完毕后手动关闭文件

```
v=open('a.text',mode='a',encoding='utf-8')
v.close()
```

执行完毕后自动会关闭文件

```
with open('a.text',mode='a',encoding='utf-8') as v：
	data=v.read()
```



4.5 文件内容的修改

```
with open('a.text',mode='r',encoding='utf-8') as f1:
    data=f1.read()
    new_data=data.replace('达啊','666')
with open('a.text',mode='w',encoding='utf-8') as f2:
    f2.write(new_data)
###小文件###
```

大文件修改

```
f1=open('a.text',mode='r',encoding='utf-8')
f2=open('a.text',mode='w',encoding='utf-8') 
for line in f1:
	new_line=line.replace('阿斯'，'死啊')
	f2.write(new_line)
f1.close()
f2.close()
```

```
with open('a.text',mode='r',encoding='utf-8') as f1,open('a.text',mode='w',encoding='utf-8') as f2:
    for line in f1:
        new_line=line.replace('阿斯'，'死啊')
        f2.write(new_line)
```

### 第五章 函数

函数分为：

- 内置函数

- 自定义函数：增加代码可读性和重用性

#### 5.1 函数基本结构

```
#函数的定义
def 函数名()
	#函数内容
	pass
#函数执行
函数名()

#注意 函数不被执行，函数内部代码是不会被知道
####注意#函数是由谁创建的，那么以后作用域就从谁开始找
```

- 任意个数

- 任意类型

  ```
  def  func(a1,a2,a3)
  	print(a1,a2,a3)
  func(1,'aaa',True)
  ```

#### 5.2参数

- 参数种类

  - 形参

    - 在函数表达式中显示。

  - 实参

    - 在调用函数时传入

      ```python
      def get_list_first_data(aaa):#形式参数（形参）
      	v=[11,22,33,44,55]
      	print(v[aaa])
      get_list_first_data(1)#实际参数（实参）位置参数
      ```

  - 位置参数（调用函数并传入参数）

    - 实参与形参位置一一对应，数量一一对应

      ```
      def func(a1,a2):
      	print(a1,a2)
      func(1,2)
      ```

  - 关键字参数（按照关键字进行传参）

    ```
    def func(a1,a2):
    	print(a1,a2)
    func(a2=2,a1=99)
    
    #关键字传参和位置传参可以混合使用
    #注意保证一点关键字参数必须在位置参数后面，总和等于形参个数。
    def func(a1,a2,a3):
    	print(a1,a2,a3)
    #func(1,2,a3=9)
    #func(1,a2=2,a3=9)
    #func(a1=1,a2=2,a3=9)
    #func(a3=9,1,2)#错误，关键字参数必须在位置参数后面
    #func(a1=1,2,a3=9)#错误，关键字参数必须在位置参数后面
    ```

  - 默认参数（定义默认值）

    - 注意默认参数值推荐使用不可变类型，慎用可变类型（有坑）
    
    ```
    默认参数必须跟在非默认参数后面，否则报错：“SyntaxError: non-default argument follows default argument”
    def func(a1,a2=123):
    	pass
    '''
    func函数接受两个参数，调用函数进行传值时。
    	func（1，2）
    	func(1,a2=1)
    	func(a1=123,a2=99)
    	func(222)#a1=222,a2等于123
    '''
    ```
  
  
  
- 无敌参数
  
  - *args
  
    - 可以接收任意位置参数，并将参数转换成 元组
  
    - 只用用位置参数进行传参
  
    - 调用函数无*
  
        ```
        def func(*rgs):
        	print(args)
        func(1，'asd ')#args=(1,'asd')
      ```
  
    - 调用函数有*
  
        ```
        def func(*args):
        	print(args)
        func(*(1，'asd') )#args=(1,'asd')
      ```
  
      练习题：
  
        ```
        def func(*args):
        	print(args)
        func(1,2,[11,22],12,'tasd','alex')#以元组的方式传入
        func(1,2)#args=(1,2)
        func((11,22,33,44))#args=((11,22,33,44),)
        func(*(11,22,33,44))#args=(11,22,33,44)
        
        ------------
        
        def func(a1,*args):
        	pass
        func(1,2,3,4,5)#a1=1,*args=2,3,4,5
        
        ------------
        
        def func(a1,*args,a2):
        	pass
        func(1,2,3,4,5,a2=12)#a1=1,*args=2,3,4,5,a2=12
        
        ------------
        
        def func(a1=10,*args,a2=123):
        	pass
        func(1,2,3,4,5)#a1=1,*args=2,3,4,5,a2=123
        ```
  
      
  
  - **kwargs
  
    - 可以接收任意关键字参数值，并将传入的参数转换为 字典。
  
    - 只能传关键字传输
  
    - 调用函数无**
  
        ```
        def func(**kwargs):
        	print(kwargs)
        func(k1=1，K2='asd')#kwargs={'k1':1,'k2':'asd'}
      ```
  
    - 调用函数有**
  
        ```
        def func(**kwargs):
        	print(kwargs)
        func(**{'k1':1,'k2':'asd'})#kwargs={'k1':1,'k2':'asd'}
      ```
  
      
  

综合*args **kwargs使用

  ```
  def func(*args，**kwargs)
  	print(args,kwargs)
  func(*[1,2,3],k1=2,k5=9 )
  func(*[1,2,3],**{"k1"=1,'K2'=2})
  ```

#####关键####

重点还是 位置参数 要在 关键字参数 前面

#### 5.3返回值

- 函数没有返回值，默认返回：None

- 函数内部执行过程遇到return，就终止

- return可以返回任意类型

```
def func(arg):
	#...
	return 9 #返回值9 ，默认返回None

#函数可以返回 任意数据
```

特殊类型返回值

```
def func():
	return 1，2，3
func()#返回值为元组（1，2，3）

```

#### 5.4作用域

在python中，一个函数就是一个作用域。

- py文件：全局作用域

- 函数：局部作用域

  - 优先在自己作用域中找，如果没有，则往上找父级的作用域，最终找到全局作用域
  - 子作用域只能读取或修改父级的值（可变类型的），不能进行复制

  ```
  NUM=9
  def func():#因为NUM是int 不可变类型，则不能修改
  	#如果想在函数内系修改（赋值）不可变类型的值，则需要使用global参数，直接影响全局作用域的。
  	global NUM
  	NUM=99#这时全局NUM则为99
  	#或者采用nonlocal参数，影响父级作用域。如果存在多层函数，则需要调用多层nonlocal才能影响全局作用域。
  NUM=[1,2,3]
  def func()
  	#NUM.append(99)#因为NUM是list，可变类型，则可以进行修改。NUM[1，2，3，99]
  ```

  

​		1.作用域中查找函数规则：优先在自己作用域找数据，自己没有就去父级域找，最终到全局作用域找。注意理清楚父级作用域中值到底是多少？

```
x=10
def func()
	x=9
	print(x)
func()
---9
```

​		练习

```
x=10
def func()：
	x=9
	print（x）
	def x1():#没执行
		x=999
		print(x)
func()
---9


x=10
def func()：
	x=9
	print（x）
	def x1():
		x=999
		print(x)
	x1()
func()
-----9----999


x=10
def func()：
	x=9
	print（x）
	def x1():
		x=999
		print(x)
	print(x)
	x1()
func()
----9---9---999

x=10
def func()：
	x=9
	print（x）
	def x1():
		x=999
		print(x)
	x1()
	print(x)
func()

----9--999-9


x = 10
def func():
    x = 8
    print(x)
    def x1():
        print(x)
    x1()
    print(x)

func()
----8-8-8


x = 10
def func():
    x = 8
    print(x)
    def x1():
        print(x)
    x = 9
    x1()
    x = 10
    print(x)

func()
----8-9-10---


x = 10
def func():
    x = 8
    print(x)
    def x1():
        print(x)

    x1()
    x = 9
    x1()
    x = 10
    print(x)

func()

---8-8--9-10
```

​	2.子作用域中只能找到父级中的值，默认无法为父级值重新赋值（int str 元组），但是可以进行修改父级值（list，dict，set（）。如果想赋值可以通过global/nonlocal强制赋值任何类型值。

-  global---赋值全局参数
-  nonlocal----赋值父级参数

练习题

```
# #####################
name = 'oldboy'
def func():
    name = 'alex' # 在自己作用域再创建一个这样的值。
    print(name)
func()
print(name)
----alex---oldboy


# #####################
name = [1,2,43]
def func():
    name.append(999)
    print(name)
func()
print(name)

----[1,2,43,999]---[1,2,43,999]

# ###################### 如果非要对全局的变量进行赋值
# 示例一
name = ["老男孩",'alex']
def func():
    global name
    name = '我'
func()
print(name)
----我---

# 示例一
name = "老男孩"#999
def func():
    name = 'alex'
    def inner():
        global name
        name = 999
    inner()
    print(name)
func()
print(name)

-----alex---999



# ############################## nonlocal
name = "老男孩"
def func():
    name = 'alex'
    def inner():
        nonlocal name # 找到上一级的name
        name = 999
    inner()
    print(name)
func()
print(name)

-----999---老男孩

```

#### 5.5函数小高级

5.5.1函数名当做变量使用

```
区分
def func():
    print(123)
list_func1=[func,func,func]
list_func2=[func(),func(),func()]
print(list_func1)#func函数代码块的内存地址
print(list_func2)#func()执行了返回None
执行结果'''
123
123
123
[<function func at 0x0000000000A90A60>, <function func at 0x0000000000A90A60>, <function func at 0x0000000000A90A60>]
[None, None, None]
'''


def func():
    return 123
list_func1=[func,func,func]
list_func2=[func(),func(),func()]
print(list_func1)#func函数代码块的内存地址
print(list_func2)#func()执行了返回123

执行结果'''
[<function func at 0x0000000000770A60>, <function func at 0x0000000000770A60>, <function func at 0x0000000000770A60>]
[123, 123, 123]
'''

def func():
    return 123

info={'k1':func,'k2':func()}
print(info)
'''
{'k2': 123, 'k1': <function func at 0x0000000001130A60>}
'''

```

5.5.2 函数当做参数进行传递

```
def func(arg)：
	print(arg)
func(1)
func([1,2,3,4])

def show ()
	return 999
func(show)
```

```
def func(arg):
    v1=arg()
    print(v1)
def show():
    print(666)

func(show)

执行结果：
666
None
```

```
def func(arg):
    v1=arg()
    print(v1)
def show():
    print(666)

result=func(show)
print(result)
执行结果：
666
None
None
```

5.5.3 函数当做函数返回值

```
def func():
	print(123)
def bar():
	return func
v=bar()#v=func


name = 'oldboy'
def func():
    print(name) 
def bar():
    return func
v = bar()
v()#func()


def bar():
    def inner():
        print(123)
    return inner
v = bar()
v()#inner()
```

```
name='oldboy'
def bar(name):
	def inner():
		print(name)
	return inner
v=bar()#{inner}
v()#{oldboy,none}
```



#### 5.6lambda表达式（匿名函数）

​	用于表示简单的函数(只用一行代码)，并且在lambda表达式内不能定义变量。

基本格式：

```
v=lambda x,y:x+y	#x,y传入参数，x+y为返回值
v(1,2)	#执行lambda函数，将1，2作为参数传入
#注意 函数不被执行，函数内部代码是不会被知道
```



```
#三元运算，为了解决简单的if else的情况，如：
if 1==1:
	a=123
else:
	a=456
a= 123 if 1==1 else: 456

lambda表达式，为了解决简单函数的情况，如：
def func（a1,a2):
	return a1+1
func1=lambda a1,a2:a1+1
```

```
DATA=100
func1=lambda:100
func2=lambda x1:x1*10
func3=lambda *args,**kwargs:len(args)+len(kwargs)
func4=lambda a1:a1+DATA

print(func1())
#100
print(func2(2))
#20
print(func3(1,2,3,4,k1='1',k2='3'))
#6
print(func4(2))
#102
```

```
DATA=100
def fun():
    DATA=1000
    func5=lambda a1:a1+DATA#因为自己没有变量，则去父级作用域里面找。
    print(func5(1))#10001
fun()#None
```

```
def big_num(a,b):
    if a>=b:
        return a
    else:
        return b
print(big_num(1,2))
func6=lambda a,b:a if a>=b else b
print(func6(1,2))
```

练习题 ：

```
#一般情况下：list所有的办法基本都不会有返回值，字符串的所有方法都有返回新值。

#1.
USER_LIST=[]
func1=lambda x:USER_LIST.append(x)
print(func1('alex'))#None
print(USER_LIST)#['alex']

#2.
func1=lambda x:x.spilt("l")
print(func1('alex'))#['a','ex']
 
#3.
FUNC_LIST=[lambda x:x.split('l'),lambda y:y+100,lambda x,y:x+y]
print(FUNC_LIST[0]('alalala'))
print(FUNC_LIST[1](1))
print(FUNC_LIST[2](1,2))
```



#### 5.7内置函数

- 自定义函数

- 内置函数

  - 其他通用函数

    - len
    - open
    - range
    - id

    - type
    -  issubclass

    ```
    #issubclass(a,b) 判断类a是否为类b的子类（派生类），子类的含义包好直接或者间接。
    #issubclass(a,b) 与type不一样，issubclass(a,b) 判断a是否为b的直接或者间接的派生类，而type是判断是否为直接。
    
    class Base(object):
        pass
    
    class Foo(Base):
        pass
    
    class Foo1(Foo):
        pass
    
    class Bar(object):
        pass
    print(issubclass(Bar,Base))#Flase
    print(issubclass(Foo1,Base))#True Foo1间接为Base派生类在issubclass中为True
    print(type(Foo1)==Base)#Flase Foo1间接为Base派生类在type中为Flase
    ```

    

    - isinstance

    ```
    #isinstance(a,b) 判断a是否为b的实例，或者是否为b的基类的实例。
    class Foo(object):
        pass
    
    class Bar(object):
        pass
    
    class Bar1(Foo)
    	pass
    obj=Bar()
    obj1=Bar1()
    print(isinstance(obj,Bar))#True
    print(isinstance(obj,Bar))#Flase
    print(isinstance(obj1,Foo))#True obj1是bar1的实例，Bar1是Foo派生类所以obj1也是Foo的实例
    ```

    - super

    ```
    #根据self对象所属类的继承关系，按顺序挨个找func方法找到‘’第一个‘’就不在继续找（如果还想继续找则继续写super（）.func（）##super(Foo,self).__init__()#会将当前self 传递给基类
    # v1=super().func()
    class Base(object):
        def func(self):
            print('base.func')
            return 123
    
    class Foo(Base):
        def func(self):
            v1=super().func()#super(Foo,self).func()
            print(v1)
            print('Foo.func')
    
    obj=Foo()
    obj.func()
    ```

    ```
    #根据self对象所属类的继承关系，按顺序挨个找func方法找到‘’第一个‘’就不在继续找（如果还想继续找则继续写super（）.func（）##
    
    class Base(object):
        def func(self):
            print('base.func')
            super().func()
            return 123
    
    class Foo(object):
        def func(self):
            print('Foo.func')
    
    class Bar(Base,Foo):
        def func(self):
            super().func()
            #print(v1)
    
    obj=Bar()
    obj.func()
    ```

    

  - 输入输出

    - input
    - print

  - 强制转换

    - list
    - set
    - tuple
    - str
    - bool
    - int
    - dict

  - 数学相关

    - 进制转换

      - bin()#0b 十进制转二进制

        ```
        a=0b1001  #可以直接转8 10 16 进制
        print(type(a))###注意这是a是int类型也就是为十进制
        
        a=10
        print(bin(a))#0b1010
        print(type(bin(a)))#<class 'str'>
        ```

        

      - oct()#0o 十进制转八进制

        ```
        a=0o11 #可以直接转2 10 16 进制
        print(type(a))###注意这是a是int类型也就是为十进制
        
        a=10
        print(oct(a))#0o12
        print(type(oct(a)))#<class 'str'>
        ```

        

      - int()其他进制转十进制

        ```
        #2进制转十进制
        a=0b1010
        print(int(a))#10
        a='0b1010'
        print(int(a,base=2))
        
        #8进制转十进制
        a=0o12
        print(int(a))#10
        a='0o12'
        print(int(a,base=8))
        
        #16进制转十进制
        a=0xa
        print(int(a))#10
        a='0xa'
        print(int(a,base=16))
        ```

      - hex()#0x

        ```
        a=0x9  #可以直接转2 8 10 进制
        print(type(a))###注意这是a是int类型也就是为十进制
        
        a=10
        print(hex(a))#0xa
        print(type(hex(a)))#<class 'str'>
        ```

      练习题：

      ```
      #1.将ip='192.168.1.2',转化为二进制
      ip_new_list=[]
      ip='192.168.1.2'
      ip_list=ip.split('.')
      for i in ip_list:
          a=bin(int(i))
          b=a.lstrip('0b').zfill(8)
          ip_new_list.append(b)
      print('.'.join(ip_new_list))
      ```

      

    - 数学其他

      - max

        ```
        v=[1,2,3,112,33]
        print(max(v))#112
        ```

      - min

        ```
        v=[1,2,3,112,33]
        print(min(v))#1
        ```

      - abs

        ```
        print(abs(-1))#1
        ```

      - float

        ```
        print(float(100))#100.0
        ```

      - sum

        ```
        v=[1,2,3,112,33]
        print(sum(v))#132
        ```

      - divmod,两个相除，得商和余数

        ```
        v=1001
        result=divmod(1001,5)
        a,b=divmod(1001,5)
        print(result)#200,1
        print(a,b)#200,1
        ```

        divmod 应用

        ```
        USER_LIST=[]
        for i in range(0,869):
            data={'name':'luwei%s'%(i,),'psd':'xyz%s'%(i,)}
            USER_LIST.append(data)
        
        LIST_len=len(USER_LIST)
        PEER_LINE=10
        PAPG_NUM,a=divmod(LIST_len,PEER_LINE)
        if a>0:
            PAPG_NUM+=1
        
        while True:
            USER_PAPG=int(input('PAPG NUM：'))
        
            if USER_PAPG<=0 or USER_PAPG>PAPG_NUM:
                print('again')
            else:
                    start_line=(USER_PAPG-1)*10
                    end_line=USER_PAPG*10
                    for i in USER_LIST[start_line:end_line]:
                        print(i)
        ```

      - pow(x,y) #返回x的y次方的值

        ```
        v=pow(2,3)
        print(v)--->8
        ```

      - round 把一个数保留小数点后几位，并且进行了四舍五入。

        ```
        v=round(1.232612,3)
        ```

      - 编码相关

        - chr() 将十进制数字转换成unicode编码中的对应字符串。unicode 包括了ascii

          ```
          v=chr(65)
          print(v)#A
          
          ```

        - ord() 将字符串转换成unicode编码中的对应的十进制数字

          ```
          v=ord('中')
          print(v)
          ```

          应用

          ```
          import random
          def get_random_code(length=6):
              data=[]
              for i in range(length):
                  v=random.randint(65,90)
                  data.append(chr(v))
              return ''.join(data)
          print(get_random_code(3))
          ```
      
      - is与==区别？is判断内存地址，==’==‘判断数值

  

  

- 高级内置函数
  
    - map()
    
      ​		map（x,y)，循环每个元素（第二个参数），然后让每个元素执行（第一个参数），将每个函数执行结果保存到新的列表中，并返回。
    
      map 有返回值。
    
      ```
    map中#第一个参数：必须是一个函数
      map中#第二个参数：必须是一个可迭代类型（list，str,tuple,set())
    v1=[11,22,33,44]
      result=map(lambda x:x+100,v1)
    print(result)#py2 111,122,133,144  #py3  <map object at 0x0000000000BC5940>
      print(list(result))#py3 111,122,133,144 
      ```
  ```
      
  - filter()
      
    ​	循环每个元素（第二个参数），然后让每个元素执行（第一个参数），将每个函数执行结果保存到新的列表中，并返回。
      
    filter 有返回值。
      
  ```
      filter中#第一个参数：必须是一个函数
    filter中#第二个参数：必须是一个可迭代类型（list，str,tuple,set())
      v1=[11,22,33,44,'asd','ac']
    result=filter(lambda x:type(x)==int,v1)
      print(list(result))
    ```
      
  - reduce()
      
    ​	functools.reduce()有返回值
      
    ```
      import functools
      v1=[11,22,33,44]
        
      def func(x,y):
          return x+y
    result=functools.reduce(func,v1)
      print(result)
  
      v1=['a','asd','qwe','fdg']
      result=functools.reduce(lambda x,y:x+y,v1)
      print(result)
    ```
      
      
    ```

#### 5.8 函数中高级

####注意#函数是由谁创建的，那么以后作用域就从谁开始找

5.8.1闭包

闭包概念：为函数中创建一块区域并为其维护自己的数据，以后执行时方便调用。【应用场景：装饰器，SQLAlchemy源码】



```
def func(name):
	def inner():
		print(name)
	return inner
v=func('luwei')
```



```
def my_func(*args):
    fs = []
    for i in range(3):#for循环被执行
        def func():#func函数不会被执行，但是for循环一直在。
            return i * i#0,1,4
        fs.append(func)#[func,func,func]
    return fs

fs1,fs2,fs3 = my_func()
print (fs1())
print (fs2())
print (fs3())
```

练习题

```
#1.
name='alex'
def base():
	print(name)
def func():
	name='eric'
	base()
func()# alex

#2.
name='alex'
def func():
	name='eric'
	def base():
		print(name)
	base()
func()# eric

#3.
name='alex'
def func():
	name='eric'
	def base():
		print(name)
	return base
base=func()
base()#eirc
```

面试题

```
info =[]
def func():
	print(item)
for item in range(10):
	info.append(func)#info=[func,func,func,func...func]
info[0]()#9
```

```
info =[]
def func():
	def inner():
		print(i)
	return inner
	
for item in range(10):
	info.append(func(item))#info=[[i=0,inner],[i=2,inner]...[i=9,inner]]
info[0]()#0
info[1]()#1
info[4]()#4
```



#### 5.9高阶函数

- 把函数当做参数传递
- 函数作为变量
- 把函数当做返回值
  - 装饰器
  - 闭包
- 生成器

注意：对函数进行赋值

函数执行流程分析（函数到底是谁创建的-画图）

![image-20191230093136062](C:\Users\davidlu\AppData\Roaming\Typora\typora-user-images\image-20191230093136062.png)

#### 5.10装饰器

​	装饰器：在不改变原函数内部代码的基础上，在函数执行之前和之后自动执行某个功能

```
def func():
	print(1)
v1=func
func=666
```

应用场景：想要为函数扩展功能时，可以选着装饰器。

装饰器格式

```
def 外层函数(参数)：
	def 内层函数(*args,**kwargs):
		return 参数(*args,**kwargs)
	return 内层函数
	
#注意使用内层函数要加*args，**kwargs是为了满足有些函数需要传入参数，有些需要传入参数。

```

装饰器应用格式

```
@外层函数
def index（）：
	pass
index（）
```

***************************************************************************************************装饰器***************************************************************************************************************************

```
def func(arg):
	def inner():
		return arg()
	return inner
def index()
	print('123')
	return '666'
#1.
v1=index()#执行index(),print 123,打印666
#2.
v2=func(index)#v2是inner函数，arg=index函数
index=666
v3=v2()#执行index(),print 123,打印666

#3.
v4=func(index)
index=v4

#4.
index=func(index)
index()
```

![image-20191231161026893](C:\Users\davidlu\AppData\Roaming\Typora\typora-user-images\image-20191231161026893.png)

```
def func(arg):
	def inner():
		print('before')
		v=arg()
		print('after')
		return v
	return inner
#第一步：执行func函数并将下面的函数参数传递，相当于func（index）
#第二步：将func返回值重新赋值给下面的函数名。index=func（index）
@func  
def index():
	print('123')
	return 666
index()
	
```

装饰器应用举例

```
import time
def func(arg):
    def inner():
        s=time.time()
        v=arg()
        e=time.time()
        print(e-s)
        return v
    return inner
@func
def func1():
    time.sleep(2)
    print('func1')
func1()

```

#### 5.11推导式

- 列表推导式 

  - 基本格式

    ```
    '''
    目的：方便的生成一个列表。
    格式：
    	v1=[i for i in 可迭代对象]
    	v2=[i for i in 可迭代对象 if 条件]#条件为true才进行append
    '''
    ```

    练习：

    ```
     	#变量=[for循环的变量， for循环一个迭代对象]
    vals=[ i for i in 'alex']
    '''
    for i in 'alex':
    	vals.append(i)
    '''
    ['a','l','e','x']
    
    vals=[ i+100 for i in range(10)]
    [100,101,102,103...109]
    
    vals=[99 if i>5 else 66 for i in range(10)]
    [66,66,66,66,66,66,99,99,99..99]
    
    def func():
    	return 100
    v4=[func for i in range(10)]
    [func,func...func]
    
    v5=[lambda:100 for i in range(10)]
    result=v5[9]()#100
    [lambda,lambda...lambda]
    
    def func():
    	return i
    v6=[func for i in range(10)]
    result=v5[9]()#9
    
    v7=[lambda:i for i in range(10)]
    result=v7[5]()#9
    
    v8=[lambda x:x*i for i in range(10)]
    #1 请问v8是什么，装有10个lamdba函数地址的列表
    #2 请问v8[0](2) 的结果是什么 18
    
    
    
    def num():
    	return [lamdba x:i*x for i  in range(4)]
    print ([m(2) for m in num()])#[6,6,6,6]
    #num()-->[lamdba，lambda，lambda，lambda]
    
    print(vals)
    
    #################筛选#####################
    v9=[i for i in range(10) if i>5] 
    #[6,7,8,9]
    ```

    

- 字典推导式

  ```
  v1={'k'+str(i):i for i in range(10)}
  ```

- 集合推导式

  ```
  v1={i for i in 'alex'}
  ```


#### 5.12异常处理

##### 5.12.1异常处理

```
try:
    v=[]
    v[111]						#IndexError
except ValueError as e:
    print('ValueError')
except IndexError as e:
    print('IndexError') 
except Exception as e:
    print(e) 					#e是Exception类的对象，中有一个错误信息，打印的是对象
finally:
    print('无论对错最后都执行')
```

```
特殊情况 try 在函数内部，函数体内部有return时仅结束函数体内部代码 try代码继续执行
一、
def func():
    try:
        v=[]
        v[111] #IndexError
        return 123
    except ValueError as e:
        print('ValueError')
    except IndexError as e:
        print('IndexError')
    except Exception as e:
        print('eorr')
    finally:
        print('无论对错最后都执行')
print(func())
'''
IndexError
无论对错最后都执行
None
'''

二、
def func():
    try:
        v=[]
        return 123
        v[111] #IndexError

    except ValueError as e:
        print('ValueError')
    except IndexError as e:
        print('IndexError')
    except Exception as e:
        print('eorr')
    finally:
        print('无论对错最后都执行')
print(func())

'''
无论对错最后都执行
123
'''

```

##### 5.12.2主动触发异常

```
try:
    vla=int(10)
    raise Exception('asdsadasd')#主动抛出错误
except Exception as e:
    print(e)
```

```
def func():
    result=True
    try:
        with open('123.txt',mode='r',encoding='utf-8') as f:
            data=f.read()
        if 'luwei' not in data:
            raise Exception('123')
    except Exception as e:
        print(e)
        result=False
    return result
print(func())
```

##### 5.12.3自定义异常处理

```
class MYerror(Exception):#继承Exception类
    pass

try:
    raise MYerror('123123')#主动触发自定义报错
except MYerror as e:
    print(e)
```

```
class MYerror(Exception):
    def __init__(self,message):
        super().__init__()
        self.message=message

try:
    raise MYerror('123123')
except MYerror as e:
    print(e.message)
```



### 第六章 模块

重点： 模块导入情况

模块加载与模块调用是两个概念，可以这么理解一次加载多次调用。

多次导入重新加载

```
import JD#第一次加载：加载一边JD中所有的内容
import JD#第一次直接或者间接加载过了，之后都不会再次加载
print(123)
```

```
import importlib
import jd
importlib.reload(jd)#主动再次加载
print(123)
```

通过模块导入的特性可以实现

```
#jd.py
class Foo(object):
	pass
obj=Foo()
```

```
#app.py
import jd#加载jd.py 最后会实例化一个Foo对象并赋值给obj
print(jd.obj)
```



#### 6.1内置模块

- os
- json
- sys
- time
- datetime
- hashlib
- getpass
- shutil
- logging

##### 6.1.1日志模块

- 基本应用（存在编码的错误）
- 日志处理本质
- 推荐处理日志
- 推荐日志处理+日志分割

注意事项：

```
#在配合try告警异常处理应用日志时，如果想要保留异常的堆栈信息
msg=str(e)
logging.error(msg,exc_info=True)#exc_info=True 显示详细错
```

###### 6.1.1.1 日志基本应用

```
import logging
#当logging.basicConfig代码加载过一次后，之后想调用直接import logging，loffing.error('ASDASD')即可
logging.basicConfig(
	filename='log1.log',
	format='%(asctime)s-%(name)s-%(module)s:%(message)',
	datefmt='%Y-%m-%d %H:%M:%S %p',
	level=logging.ERROR
	#level=30
)
#第二次logging日志不进行加载，当python代码执行编译的时候发现已经存在logging的配置，所以不会再进行其他logging编译。
logging.basicConfig(
	filename='log2.log',
	format='%(asctime)s-%(name)s-%(module)s:%(message)',
	datefmt='%Y-%m-%d %H:%M:%S %p',
	level=logging.ERROR
	#level=30
)

logging.debug('debug')
logging.info('info')
logging.warning('warning')
logging.error('error')
logging.critical('critical')
#logging.log(10,'log')
'''
CRITICAL = 50
FATAL = CRITICAL
ERROR = 40
WARNING = 30
WARN = WARNING
INFO = 20
DEBUG = 10
NOTSET = 0
'''
```

日志模块应用

```
import logging
import requests

logging.basicConfig(
	filename='log1.log',
	format='%(asctime)s-%(name)s-%(levelname)s-%(module)s:%(message)s',
	datefmt='%Y-%m-%d %H:%M:%S %p',
	level=logging.DEBUG
	)
try:
    requests.get('http://www.xx.com')
except Exception as e:
    msg=str(e)#由于e为对象，所以print(e)是在执行Exception的__str__方法
    logging.error(msg,exc_info=True)#exc_info=True显示详细报错
```

###### 6.1.1.2日志处理本质

```
import logging
file_handler=logging.FileHandler('log.log','a',encoding='utf-8')
fmt=logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s')
file_handler(fmt)
logger=logging.Logger('xxx',level=logging.ERROR)
logger.addHandler(file_handler)
logger.error('hhhasdsad')
```

###### 6.1.1.3推荐日志处理

```
import logging
file_handler=logging.FileHandler('log.log','a',encoding='utf-8')
logging.BasicConfig=(
	handlers=[file_handler,],
	format='%(ascname)-%(name)s-%(levelname)s-%(module)s: %(message)s',
	datafmt='%Y-%m-%d %H:%M:%S %p',
	level=logging.ERROR
)
logging.error('asdsadasd')
```

###### 6.1.1.4日志切割+推荐日志处理

```
import logging
import time
from logging import handlers
file_handler=handlers.TimedRotatingFileHandler(filename='log.log',when='s',interval=5,encoding='utf-8')
logging.BasicConfig=(
	handlers=[file_handler,],
	format='%(ascname)-%(name)s-%(levelname)s-%(module)s: %(message)s',
	datafmt='%Y-%m-%d %H:%M:%S %p',
	level=logging.ERROR
)
logging.error('asdsadasd')

```

##### 6.1.2 importlib

根据字符串形式导入一个模块

```
#用字符串的形式导入模块
import importlib

v=importlib.import_module('x.y')#等于from x import y

#用字符串的形式去对象(模块)找到成员。
func1=getattr(v,'func')
#执行对象中方法
func1()
```



##### 6.2第三方模块

- request
- xlrd

#### 6.3自定义模块

- 文件
- 文件夹/包（__ Init __)

```
import 模块
from 模块.模块 import 模块
from 模块.模块.模块 import 函数
```

相对导入但是不推荐

```
from . import xxx
from .. import xxx
```

```
if '__name__'='__main__'#判断是否为文件，如果是主文件则执行

```

#### 6.1 三元运算

```
v=前面 if 条件 else 后面

等于：
if 条件：
	v=前面
else：
	v=后面
```

```
 #让用户输入值，如果值为整数，则转换成整数，否则赋值为None
data=input('>>>')
value=int(data) if data.isdecimal() else None
```

#### 6.2hashlib -md5

将指定的"字符串"进行加密

```
import hashlib
obj=hashlib.md5()
obj.update('123'.encode('utf-8'))
result=obj.hexdigest()
print(result)


def get_md5(data):
    obj = hashlib.md5()
    obj.update(data.encode('utf-8'))
    result = obj.hexdigest()
    return result
val=get_md5('123')
print(val)

```

- 加盐

```
import hashlib
def get_md5(data):
    obj = hashlib.md5()
    obj.update(data.encode('utf-8'))
    result = obj.hexdigest()
    return result
val=get_md5('123')
print(val)
```

应用

```

import hashlib,getpass

def get_md5(data):
    obj=hashlib.md5('123asd'.encode('utf-8'))
    obj.update(data.encode('utf-8'))
    result=obj.hexdigest()
    return result
def register():
    print('register'.center(40,'+'))
    while True:
        user=input('new_username:')
        if user.lower() =='n':
            return
        psd=input('new_password:')
        i={'username':user,'password':get_md5(psd)}
        l.append(i)

def login():
    print('login'.center(20,'*'))
    count = 0
    while True:
        login_user=input('login_username:')
        login_psd=input('login_password:')
        for i in l:
            if login_user==i['username'] and get_md5(login_psd)==i['password']:
                return True
            count += 1
            print(count)
            if count == 5:
                return
l = []
register()
result=login()
if result:
    print('ok')
else:
    print('no')

```

#### 6.3 getpass 输入不显示在屏幕

```
import  getpass
pwd=getpass.getpass('password:')
print(pwd)
```



### 第七章 面向对象

面向对象基本了解：

```
class Foo(object):
	def func(self):
		pass
obj=Foo()
obj.func()
```

- 谈谈你了解的面向对象？ 

  ​	针对面向对象三个特性开始聊。封装，继承，多态

- 类和对象是什么关系？

  ​    对象是类的一个实例

- self是什么?

  ```
  #self就是一个形式参数,对象调用方法时 python内部将该对象传给这个参数。
  class Foo(object)：
  	def func(self):
  		pass
  obj=Foo()
  obj.func()
  ```

- 类成员&对象成员以及他们之间的关系

  对象能访问类变量，但不能修改类变量

- 类和对象 都可以当做变量或嵌套到其他类型中。

  ```
  class Foo(object):
  	def run(self):
  		pass
  v=[Foo,Foo]
  v=[Foo(),Foo()]
  obj=Foo()
  v=[obj.run,obj.run,]
  ```

#### 7.1类中成员

##### 7.1.2类中特殊成员

```
1.__new__
2.__call__
3.__setitem__,__getitem__,__delitem__
4.__str__
5.__dict__
6.上下文管理，__enter__,__exit__
7.对象相加
8.__init__
9.__iter__
```

###### 7.1.2.1 __ init __(self)

```
#用于初始化对象，给对象进行赋值，初始化方法
class Foo(object):

    def __init__(self,x):
        print('初始化对象 ')
        '''
        用于给对象进行复制，初始化方法
        :param x:
        '''
        self.x=x
obj=Foo(1)
```

###### 7.1.2.2__ new __(self)

```
#用于创建空的对象，构造方法，实例化一个对象时，先进行new方法
class Foo(object):
    def __new__(cls, *args, **kwargs):
        '''
        用于创建空的对象，构造方法
        :param args:
        :param kwargs:
        :return:
        '''
        print('创建对象')
        return object.__new__(cls)
obj=Foo(1)
```

###### 7.1.2.3__ call__(self, *args, **kwargs)

```
#一般情况下我们都是实例化对象之后，调用对象内部方法[对象.方法()]，如果直接执行对象()则会调用__call__(self, *args, **kwargs)方法
#对象加()执行类中call方法。
class Foo(object):
    def __call__(self, *args, **kwargs):
        print('执行call方法')
obj=Foo(1)
obj()

Foo()()
```

###### 7.1.2.4 __ getitem __ , __ setitem __ , __ delitem __

```
#字典其实也是类。obj2是通过dict实例化出来的对象。对象加[]执行类中相关的方法
obj2=dict()
obj2['k1']=123
class Foo3(object):
    def __setitem__(self, key, value):
        print('执行setitem,key:%s,value:%s'%(key,value))

    def __getitem__(self, item):
        print('执行getitem,item:%s'%(item))
        return item+'llll'

    def __delitem__(self, key):
        print('执行delitem,item:%s'%(key))
        return key+'keykey'

obj3=Foo3()
obj3['k3']=123            #内部会自动调用__setitem__方法
val=obj3['k2']            #内部会自动调用__getitem__方法
print(val)
del obj3['k4']            #内部会自动调用__delitem__方法
```

###### 7.1.2.5 __ str __()

```
class Foo(object):
    def __str__(self):
        '''
        当打印对象时，会自动调用该方法，将__str__方法返回值就打印在页面上
        :return:
        '''
        return 'asdasd'
obj=Foo()
print(obj,type(obj))
#asdasd <class '__main__.Foo'>
```

###### 7.1.2.6__ dict __

```
#将对象中所有变量以字典的形式打印
class Foo(object):
    def __init__(self,name,age,email):
        self.name=name
        self.age=age
        self.email=email

obj=Foo('luwei',20,'663969502@qq.com')
print(obj.name)
print(obj.age)
print(obj.email)
val=obj.__dict__#__ dict __去对象中找到所有变量并将其转换为字典
print(val)
```

###### 7.1.2.7上下文管理【面试】

```
#__enter__,__exit__#先执行enter 在执行自己的代码 最后执行exit
class Foo(object):
    def __enter__(self):
        self.open=open('123.txt',mode='a',encoding='utf-8')
        return self.open   #enter方法返回什么
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.open.close()

with Foo() as f:#f是什么 是由__ENTER__方法返回值所决定
    f.write('asd')
    f.write('asd')
    f.write('asd')
```

###### 7.1.2.8对象相加__ add __

```
class Foo(object):
    def __add__(self, other):
        print(self,other)
        return 123

obj1=Foo()
obj2=Foo()
val=obj1 + obj2
#由obj1触发add方法，add 方法中self为obj1，other为obj2
```

###### 7.1.2.9 __ iter __

```
class Foo(object):
	def __iter__(self):
		return iter([1,2,3,4])#返回迭代器
obj=Foo()
#可迭代对象，类中具有__iter__方法，并且返回一个迭代器或者生成器
```



#### 7.2单例模式

无论函数实例化多少次，永远用的都是一次实例化出的对象。

```python
class Foo(object):
    PASS
 #多例，每实例化一次就创建一个新的对象
obj1=Foo()
obj2=Foo()
#单例，无论实例化多少次，都用第一次创建的那个对象
```

单例模块标准

```
class Singleton(object):
	instance=None
	def __new__(cls,*arg,**kwargs):
		if not cls.instance:
			return cls.instance==object.__new__(cls)
		return cls.instance
obj1=Singleton()
obj2=Singleton()
#后续还需要进行加锁补充
```

单例使用场景

```
多个客户端连接数据库
举例 读取文件
class FileHelper(object):
    instance=None
    def __new__(cls, *args, **kwargs):
        if not cls.instance:
            cls.instance= object.__new__(cls)
        return cls.instance
    def __init__(self,path):
        self.file_object=open(path,mode='r',encoding='utf-8')

ob1=FileHelper('x')
print(ob1.file_object.read(1))
ob2=FileHelper('x')
print(ob2)
```

#### 7.2可迭代对象

表象：可以被for循环对象就可以称为是可迭代对象：'xx',[1,2,3,4],{1,2,3,4}

```
class Foo():
	pass
obj=Foo()
```

如何让一个对象变成可迭代对象？

在类中实现__ iter __方法且返回一个迭代器（生成器）

```
class Foo(object):
	def __iter__(self):
		return iter([1,2,3,4])#返回迭代器
obj=Foo()

class Foo(object):
	def __iter__(self):
		yield 1 	#返回生成器
		yield 2
		yield 3
obj=Foo()
```

记住：只要能被for循环就是执行iter方法

##### 7.2.1





#### 7.3约束+异常处理

```
class Interface(object):
    def send(self):
        raise NotImplementedError()#主动发出异常告警

class Base(Interface):
    def send(self):
        pass

class Foo(Interface):
        pass

obj=Foo()
obj1=Base()
obj.send()
obj1.send()
```

#### 7.4反射

根据字符串的形式对某个对象中操作他的成员

- getattr(对象，'字符串')根据字符串的形式去对某个对象中获取对象的成员
- setattr(对象，变量，'值')根据字符串的形式去某个对象中设置成员
- hasattr(对象，'字符串')根据字符串的形式去某个对象判断是否有该成员对象的成员
- delattr（对象，’字符串‘）根据字符串的形式去某个对象中删除成员

```
class Foo(object):
    def __init__(self,name):
        self.name=name
	def login(self):
		pass
obj=Foo('luwei')
#获取变量
v1=getattr(obj,'name')#==obj.name
print(v1)
print(obj.name)
setattr(obj,'name','llll')#obj.name='llll'
print(getattr(obj,'name'))
if not hasattr(obj,'login')
	return 'no no no '
#获取方法
method_name=getattr(obj,'login')
method_name()
#删除成员
delattr(obj,'name')
```

python一切皆对象，所以以后想要通过字符串的形式操作其内部成员都可以反射的机制实现。











### 第八章 网络编程



### 第九章 并发编程



### 第十章 数据库



### 第十一章 前端开发



### 第十二章 Django框架





### 项目结构目录

- ---项目file

  - ---bin

    - 可执行文件.程序入口
    - admin.py
    - student.py
    - teacher.py

  - ---config

    - 配置

  - ---db

    - 数据库

  - ---lib

    - 公共代码

  - ---src

    - 业务代码

  - log

    - log日志

    

### 附录

#### 单词

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

#### 错误记录：

###### py2 与py3区别

- 默认解释器编码
- 输入输出
- int
  - int long
  - 除法
- range和xrange
- 导入模块和包 __ init __()
- 字典
  - key
    - py2： 列表，可以循环可以索引取值
    - py3：迭代器 ，可以循环不可以索引取值
  - vaules
    - py2：类比，可以循环可以索引取值
    - py3：迭代器，可以循环不可以索引取值
  - items
    - py2：类比，可以循环可以索引取值
    - py3：迭代器，可以循环不可以索引取值
- map/filter
  - py2：列表
  - py3：返回迭代器，可以循环不可以索引取值，可以使用list 转为列表

注意重点##########

py2中unicode类型（unicode编码）与str（utf-8，gbk，等编码）类型

py3中str类型（unicode编码）与bytes（utf-8，gbk，等编码）类型

```
py2unicode就是py3中str（unicode编码）
py2str就是py3中bytes（utf-8，gbk，等编码）
```









```
v1=1
v2=(1)
v3=(1,)
print(type(v1),type(v2),type(v3),)


看代码分析结果
def func(arg):
    return arg.pop(1)
result = func([11,22,33,44])
print(result)


def f1():
    print('f1')
    return f3()
def f2():
    print('f2')
    return f1
def f3():
    print('f3')
func = f2()
result = func()
print(result)



def func(num):
    def inner():
        print(num)
    return inner
result = []
for i in range(10):
    f = func(i)
    result.append(f)
print(i)#9
print(result)#[inner,inner...inner]
v1 = result[0]()#0！！！！
v2 = result[9]()#9
print(v1,v2)

```

